#!/usr/bin/env bash

# Distro detection functions
get_distro() {
        if [[ -f /etc/os-release ]]; then
                source /etc/os-release
                echo "${ID:-unknown}" | tr '[:upper:]' '[:lower:]'
        else
                echo "unknown"
        fi
}

get_distro_family() {
        if [[ -f /etc/os-release ]]; then
                source /etc/os-release
                # First check ID_LIKE, then fall back to ID
                echo "${ID_LIKE:-${ID:-unknown}}" | tr '[:upper:]' '[:lower:]'
        else
                echo "unknown"
        fi
}

# Package manager detection
get_package_manager() {
        local distro=$(get_distro)
        local distro_family=$(get_distro_family)
        
        case "$distro" in
                aurora|fedora) echo "dnf" ;;
                arch|endeavouros|manjaro) echo "pacman" ;;
                ubuntu|debian|pop) echo "apt" ;;
                opensuse*) echo "zypper" ;;
                *) 
                        # Try distro family
                        case "$distro_family" in
                                fedora|rhel) echo "dnf" ;;
                                arch|archlinux) echo "pacman" ;;
                                debian|ubuntu) echo "apt" ;;
                                *) echo "unknown" ;;
                        esac
                        ;;
        esac
}

# Universal package installation
install_packages() {
        local pm=$(get_package_manager)
        case "$pm" in
                dnf) sudo dnf install -y "$@" ;;
                pacman) sudo pacman -S --noconfirm "$@" ;;
                apt) sudo apt install -y "$@" ;;
                zypper) sudo zypper install -y "$@" ;;
                *) 
                        echo "Error: Unknown package manager for distro $(get_distro)" >&2
                        return 1 
                        ;;
        esac
}

# Check if package is installed
is_package_installed() {
        local package=$1
        local pm=$(get_package_manager)
        
        case "$pm" in
                dnf) rpm -q "$package" &>/dev/null ;;
                pacman) pacman -Qq "$package" &>/dev/null ;;
                apt) dpkg -l "$package" 2>/dev/null | grep -q "^ii" ;;
                zypper) rpm -q "$package" &>/dev/null ;;
                *) return 1 ;;
        esac
}

check_root() {
        if [[ $EUID -ne 0 ]]; then
                echo "This script requires root privileges. Please enter your password."
                exec sudo "$0" "$@"
        fi
}

load_env() {
        local env_file="${1:-.env}" # Default to .env if no argument is provided
        local prefix=""
        local specific_keys=()
        local OPTIND opt

        # Resolve the path relative to the current script's location
        local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        env_file="$(cd "$script_dir" && realpath -s "$env_file")"

        # Parse additional options
        shift # Remove the first argument (env_file) from the argument list
        while getopts ":p:k:" opt; do
                case $opt in
                p) prefix="$OPTARG" ;;
                k) IFS=',' read -ra specific_keys <<<"$OPTARG" ;;
                \?)
                        echo "Invalid option -$OPTARG" >&2
                        return 1
                        ;;
                :)
                        echo "Option -$OPTARG requires an argument." >&2
                        return 1
                        ;;
                esac
        done

        if [[ ! -f "$env_file" ]]; then
                echo "Error: $env_file does not exist." >&2
                return 1
        fi

        echo "Loading .env file: $env_file"

        while IFS= read -r line || [[ -n "$line" ]]; do
                if [[ ! $line =~ ^\s*# && -n $line ]]; then
                        if [[ $line =~ ^([^=]+)=(.*)$ ]]; then
                                key="${BASH_REMATCH[1]}"
                                value="${BASH_REMATCH[2]}"

                                key=$(echo "$key" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
                                value=$(echo "$value" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^["\x27]\(.*\)["\x27]$/\1/')

                                if [[ -z "$prefix" && ${#specific_keys[@]} -eq 0 ]] ||
                                        [[ -n "$prefix" && "$key" == "$prefix"* ]] ||
                                        [[ " ${specific_keys[*]} " =~ " $key " ]]; then
                                        export "$key=$value"
                                        echo "Loaded: $key"
                                fi
                        fi
                fi
        done <"$env_file"
}

unload_env() {
        local prefix="${1:-}"

        if [[ -z "$prefix" ]]; then
                echo "Error: Prefix not provided." >&2
                return 1
        fi

        # Find all environment variables starting with the prefix and unset them
        for var in $(compgen -v "${prefix}"); do
                unset "$var"
                echo "Unset: $var"
        done
}

check_command() {
        command -v "$1" >/dev/null 2>&1 || {
                echo >&2 "Command '$1' not found. Exiting."
                return 1
        }
}
